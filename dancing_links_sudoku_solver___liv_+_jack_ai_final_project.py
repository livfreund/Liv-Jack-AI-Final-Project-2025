# -*- coding: utf-8 -*-
"""Dancing Links Sudoku Solver  |  Liv + Jack AI Final Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12yShIOfiFeoDrIrxDcrpk5EjHT9h8RhV

**How the Dancing Links algorithm works:** The Dancing Links algorithm begins by converting the puzzle into an exact cover problem, where each possible placement of a number corresponds to a row in a constraint matrix. This matrix is implemented as a sparse, doubly linked structure that allows rows and columns to be removed and restored efficiently. The algorithm then applies Knuthâ€™s Algorithm X. The algorithm selects the constraint column with the fewest remaining options, covers that column, and then tries each row in that column as part of the solution. For each chosen row, the algorithm covers all related columns, recursively continues the search, and backtracks if a contradiction is reached. When all constraint columns are successfully covered, the algorithm has found a complete solution.
"""

class Node:
    def __init__(self):
        self.left = self.right = self.up = self.down = self
        self.column = None
        self.row_id = None

class Column(Node):
    def __init__(self, name):
        super().__init__()
        self.size = 0
        self.name = name

"""**Defining Our Matrix Entries:** Utilizing a double linked list, we define each of our nodes (or, entries in our Sudoku puzzle) as being linked in all four directions. We also define our 'Column', which are the constraints each entry faces. These are our two essential data structures for implementing Dancing Links."""

class DLX:
    def __init__(self, columns):
        self.header = Column("header")
        self.columns = []

        prev = self.header
        for col_name in columns:
            col = Column(col_name)
            self.columns.append(col)
            col.right = prev.right
            col.left = prev
            prev.right.left = col
            prev.right = col
            prev = col

        self.solution = []


        self.recursive_calls = 0
        self.moves = 0
        self.backtracks = 0
        self.candidate_checks = 0
        self.branching_choices = []

    def append_row(self, row_id, col_indices):
        first_node = None
        for col_idx in col_indices:
            column = self.columns[col_idx]
            node = Node()
            node.column = column
            node.row_id = row_id
            node.down = column
            node.up = column.up
            column.up.down = node
            column.up = node
            column.size += 1

            if first_node is None:
                first_node = node
                node.right = node.left = node
            else:
                node.right = first_node
                node.left = first_node.left
                first_node.left.right = node
                first_node.left = node

    def cover(self, col):
        col.right.left = col.left
        col.left.right = col.right
        for row in self.iter_down(col):
            for node in self.iter_right(row):
                node.down.up = node.up
                node.up.down = node.down
                node.column.size -= 1

    def uncover(self, col):
        for row in self.iter_up(col):
            for node in self.iter_left(row):
                node.column.size += 1
                node.down.up = node
                node.up.down = node
        col.right.left = col
        col.left.right = col

    def iter_right(self, node):
        cur = node.right
        while cur != node:
            yield cur
            cur = cur.right

    def iter_left(self, node):
        cur = node.left
        while cur != node:
            yield cur
            cur = cur.left

    def iter_down(self, col):
        cur = col.down
        while cur != col:
            yield cur
            cur = cur.down

    def iter_up(self, col):
        cur = col.up
        while cur != col:
            yield cur
            cur = cur.up

    def search(self, solution_callback):
        self.recursive_calls += 1

        if self.header.right == self.header:
            solution_callback(self.solution.copy())
            return True

        col = None
        min_size = 10**9
        c = self.header.right
        while c != self.header:
            if c.size < min_size:
                min_size = c.size
                col = c
            c = c.right

        self.cover(col)

        branching = 0
        for row in self.iter_down(col):
            branching += 1
        self.branching_choices.append(branching)

        for row in self.iter_down(col):
            self.candidate_checks += 1
            self.solution.append(row.row_id)
            self.moves += 1

            for node in self.iter_right(row):
                self.cover(node.column)
            #Recurse
            if self.search(solution_callback):
                return True
            #Backtrack
            self.solution.pop()
            self.backtracks += 1
            for node in self.iter_left(row):
                self.uncover(node.column)

        self.uncover(col)
        return False

"""**Algorithm X with Dancing Links:** This is where we implement Algorithm X with Dancing Links. Our append_row method places possible choices for each cell into our matrix, linking them horizontally and vertically. Our core functions are then cover, and uncover. The former temporarily removes entries in order to enforce our puzzle constraints and then backtrack cleanly. The latter allows us to move forward once the backtracking is complete without losing our stored information. This algorithm utilizes a recursive depth-first search, where we search through candidate rows, cover, then further recurse. If we reach a dead end, the algorithm backtracks and removes the original choice.  """

def sudoku_dlx_solve(board):
    #Defining all our constraints
    columns = []
    for i in range(9):
        for j in range(9):
            columns.append(f"cell-{i}-{j}")
    for i in range(9):
        for d in range(1, 10):
            columns.append(f"row-{i}-{d}")
    for j in range(9):
        for d in range(1, 10):
            columns.append(f"col-{j}-{d}")
    for b in range(9):
        for d in range(1, 10):
            columns.append(f"box-{b}-{d}")

    dlx = DLX(columns)

    def col_index_cell(i, j):
        return 9 * i + j
    def col_index_row(i, d):
        return 81 + 9 * i + (d - 1)
    def col_index_col(j, d):
        return 162 + 9 * j + (d - 1)
    def col_index_box(b, d):
        return 243 + 9 * b + (d - 1)

    for i in range(9):
        for j in range(9):
            b = (i // 3) * 3 + (j // 3)
            if board[i][j] == '.':
                digits = range(1, 10)
            else:
                digits = [int(board[i][j])]

            for d in digits:
                row_id = (i, j, d)
                dlx.append_row(
                    row_id,
                    [
                        col_index_cell(i, j),
                        col_index_row(i, d),
                        col_index_col(j, d),
                        col_index_box(b, d)
                    ]
                )

    solution_rows = []

    def callback(sol):
        solution_rows.extend(sol)

    dlx.search(callback)

    # Build solved grid
    grid = [[0]*9 for _ in range(9)]
    for (i, j, d) in solution_rows:
        grid[i][j] = d

    return grid, dlx

"""**Sudoku as an Exact Cover Problem:** Sudoku is an example of the exact cover problem wherein many choices must be made over a set of constraints so that proper coverage of the entire problem is satisfied. In this section, we define exactly how it is an exact cover problem, where the puzzle is constrained by the cell, row, column, and box restrictions. Each possible placement in our puzzle, defined by i(row), j(column), and d(digit), then becomes a row in our Dancing Links (DLX) matrix where it is linked to the four Sudoku constraints. We then run the Dancing Links algorithm, and when a solution is found it is called back to our solution grid as d."""

if __name__ == "__main__":
    #Easy
    puzzle1 = [
        "53..7....",
        "6..195...",
        ".98....6.",
        "8...6...3",
        "4..8.3..1",
        "7...2...6",
        ".6....28.",
        "...419..5",
        "....8..79"
    ]

    #Medium
    puzzle2 = [
        "1.....7..",
        ".3..2....",
        "..9..6..8",
        ".6..1....",
        "....7....",
        "....9..1.",
        "7..3..5..",
        "....8..2.",
        "..5.....4"
    ]

    #Hardest
    puzzle3 = [
        ".........",
        ".........",
        ".........",
        ".........",
        ".........",
        ".........",
        ".........",
        ".........",
        "........."
    ]

    puzzles = [puzzle1, puzzle2, puzzle3]

    for idx, puzzle in enumerate(puzzles, start=1):
        solution, dlx = sudoku_dlx_solve(puzzle)
        print("\nSolved Sudoku:")
        for row in solution:
            print(row)

        print("\nChoices by Box:", dlx.branching_choices)
        if dlx.branching_choices:
            avg_branching = sum(dlx.branching_choices) / len(dlx.branching_choices)
            print("Average Choices per Box:", avg_branching)

"""**Manual Puzzle Execution:** This is where we manually input Sudoku problems. There are three problems varying is difficulty based on how many cells are filled in. We have also put a ticker on the amount of options our algorithm has at any given points--a higher number of options means a higher difficulty. Our "Average Choices per Box" metric essentially creates a difficulty scale of puzzles from 1-2.296..."""

import random

def generate_random_sudoku(empty_cells=50):
    blank_board = ["." * 9 for _ in range(9)]
    solved_grid, _ = sudoku_dlx_solve(blank_board)

    puzzle = []
    for i in range(9):
        row = ""
        for j in range(9):
            row += str(solved_grid[i][j])
        puzzle.append(row)

    cells = [(i, j) for i in range(9) for j in range(9)]
    random.shuffle(cells)
    for k in range(empty_cells):
        i, j = cells[k]
        puzzle[i] = puzzle[i][:j] + "." + puzzle[i][j+1:]

    return puzzle

if __name__ == "__main__":
    puzzle = generate_random_sudoku(empty_cells=50)

    print("Random Puzzle:")
    for row in puzzle:
        print(row)

    solution, dlx = sudoku_dlx_solve(puzzle)
    print("\nSolved Sudoku:")
    for row in solution:
        print(row)

    print("\nChoices by Box:", dlx.branching_choices)
    if dlx.branching_choices:
        avg_branching = sum(dlx.branching_choices) / len(dlx.branching_choices)
        print("Average choices per box:", avg_branching)

"""**Random Puzzle Execution:** We have also created a generator for random Sudoku problems that create games that have at least one solution."""